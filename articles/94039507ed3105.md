---
title: "awaitする場合としない場合の比較"
emoji: "⏱️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [javascript, typescript]
published: false
---

前回、不要な`await`について書いた記事の続きです。

@[card](https://zenn.dev/nanase99/articles/856861b792deba)

こちらの記事では、なんとなくで書きがちな`await`について、不要となるケースを記載していました。

```diff js
async function getUsers() {
  const res = await fetch("/api/users");
  if (res.status !== 200) {
    throw new Error("エラーだよ");
  }
  const data = await res.json(); // ← ここでのawaitはあってもなくても動作は変わらない
  return data;
}
```

その中で実際にパフォーマンスの比較を行いましたが、比較対象が不十分だったため、本記事で改めて検証結果を記載します。

## パフォーマンスの比較
今回は下記の3パターンで比較してみました。
- `async await`
- `async no await`
- `no async`

それぞれ下記のように定義しています。

```js
// async関数でawaitする
async function asyncAwait() {
  return await Promise.resolve(0);
}

// async関数でawaitしない
async function asyncNoAwait() {
  return Promise.resolve(0);
}

// 通常の関数
function noAsync() {
  return Promise.resolve(0);
}
```

これらをvitestのベンチマークテストで検証した結果がこちらです。

実行環境
- node v22.13.1
- vitest v3.1.1

```sh
 ✓ async.bench.js 4582ms
     name                    hz     min     max    mean     p75     p99    p995    p999     rme  samples
   · asyncAwait    7,684,032.76  0.0000  1.3435  0.0001  0.0001  0.0002  0.0002  0.0003  ±0.66%  3842017   slowest
   · asyncNoAwait  8,264,645.39  0.0000  0.1803  0.0001  0.0001  0.0002  0.0002  0.0003  ±0.46%  4132323
   · noAsync       9,514,842.17  0.0000  6.2526  0.0001  0.0001  0.0001  0.0002  0.0003  ±2.52%  4757422   fastest

 BENCH  Summary

  noAsync - async.bench.js
    1.15x faster than asyncNoAwait
    1.24x faster than asyncAwait
```

パッと結果が分かりづらいので、実行速度が速い順に再掲するとこちらのようになります。

```js
// 通常の関数(fastest)
function noAsync() {
  return Promise.resolve(0);
}

// async関数でawaitしない(slowest)
async function asyncNoAwait() {
  return Promise.resolve(0);
}

// async関数でawaitする
async function asyncAwait() {
  return await Promise.resolve(0);
}
```

また、`noAsync`は、
- `asyncNoAwait`に比べて1.15倍速い
- `asyncAwait`に比べて1.24倍速い
結果となりました。

:::details 【参考】StackBlitzでの比較

ちなみにStackBlitzで検証した場合、`asyncAwait`と`asyncNoAwait`の順序が逆転する結果となりました。

@[stackblitz](https://stackblitz.com/edit/await-vs-without-await-z6fwvoev-igwc7gys?embed=1&file=async.bench.js&view=editor)

これは、StackBlitzがWebContainerで実行されているなどが関係していそうですが、詳しく特定することはできていません。
:::

-----

以上の結果から、パフォーマンスの観点では**通常の関数としてPromiseをそのまま返す**が一番有利という内容になりました。

しかし、通常のAPI呼び出しを考えると、ステータスコードの判定を行う目的でfetch結果に対して`await`を使用するなどで、async関数として定義することが場面の方が多いかと思われます。

そのため、async関数同士で比較した場合について考えます。

### asyncAwait vs asyncNoAwait

ESLintではasync関数で`await`を使用したreturn文を不正とするルールが存在していましたが、現在は非推奨のルールとなっています。
@[card](https://eslint.org/docs/latest/rules/no-return-await)

その理由として下記のように記載されています。

> The original intent of this rule was to discourage the use of return await, to avoid an extra microtask. However, due to the fact that JavaScript now handles native Promises differently, there is no longer an extra microtask. More technical information can be found in [this V8 blog entry](https://v8.dev/blog/fast-async).

すなわち、従来まではasync関数にて`await`を書いた場合は余分なマイクロタスクを避けるためのルールであったが、現在ではそれらの追加のマイクロタスクが不要となったため、非推奨となったようです。

現状に至るまでの経緯については、こちらの記事が参考になるかと思います。

@[card](https://zenn.dev/catallaxy_dev/articles/7a1610273e79c5)

上記でも論じているように、実態として`asyncAwait`と`asyncNoAwait`を比較すると、後者の方が有利ではあるものの、決定的な違いにはなり得ないといったところでしょうか。

## パフォーマンス以外の視点で見た場合
async関数内で`await`を使用する場合と使用しない場合とで、パフォーマンス以外にも違いが生じることになります

### 例外をキャッチする場所
`await`を使用した場合、例外はそのスコープでキャッチすることができます。

一方で`await`を使用しない場合、例外はその呼び出し元でしかキャッチすることができません。

```js
function rejectPromise() {
  return Promise.reject(new Error('エラー'));
}

// ① await ありの場合
async function withAwait() {
  try {
    return await rejectPromise();
  } catch (_e) {
    console.log('withAwaitはここでcatchされる');
  }
}

// ② await なしの場合
async function withoutAwait() {
  try {
    return rejectPromise(); // awaitしない
  } catch (_e) {
    console.log('ここは呼び出されない');
  }
}

withAwait().catch((_e) => console.log('ここは呼び出されない'));
withoutAwait().catch((_e) => console.log('withoutAwaitはここでcatchされる'));
```

:::details stackblitz
@[stackblitz](https://stackblitz.com/edit/vitejs-vite-foquyhkl?embed=1&file=try-catch.js&view=editor)
:::

つまり、`await`を使用することでその関数内の`catch`句で例外を捉えることができます。

逆に`await`を使用しない場合は、その呼び出し元の`catch`句でしか例外を捉えることができません。

この差は、`await`によってPromiseが決定されるまで待機するかどうかの違いにより生じます。

**`await`でPromiseの決定を待機する場合**
1. `await`によりPromiseが解決または拒否されるまで待機する
2. `Promise.reject`によりPromiseが拒否される
3. 拒否されたタイミングでは、処理がまだ関数内
4. そのため関数内の`catch`句で捕捉される

**`await`を使用せずにPromiseの決定を待機しない場合**
1. `await`がないためPromiseが解決または拒否されるまで待機しない
2. `Promise.reject`によりPromiseが拒否される
3. 拒否されたタイミングでは、関数内での処理は終了している
4. そのため関数の呼び出し元の`catch`句で捕捉される

### スタックトレースの内容
`await`の有無で、スタックトレースの出力にも差が生じます。

```js
async function rejectPromise() {
  await Promise.resolve();
  throw new Error('エラーが発生しました');
}

// ① await ありの場合
async function withAwait() {
  return await rejectPromise();
}

// ① await なしの場合
async function withoutAwait() {
  return rejectPromise();
}

withAwait().catch((error) => console.log(error.stack));
withoutAwait().catch((error) => console.log(error.stack));
```

```sh
Error: エラーが発生しました
    at rejectPromise (/home/projects/vitejs-vite-foquyhkl/stacktrace.js:3:9)
    at async withAwait (/home/projects/vitejs-vite-foquyhkl/stacktrace.js:8:10)
Error: エラーが発生しました
    at rejectPromise (/home/projects/vitejs-vite-foquyhkl/stacktrace.js:3:9)
```

:::details stackblitz
@[stackblitz](https://stackblitz.com/edit/vitejs-vite-8hmchfuv?embed=1&file=stacktrace.js&view=editor)
:::

## まとめ

- 従来はasync関数内で不要な`await`を省略することでパフォーマンスが向上していたが、現在ではPromiseの取り扱いが変わり。大きな差がなくなっている。
- `await`を使用することで、そのスコープ内で`catch`することができる
- `await`を使用することで、スタックトレースの内容が詳細になる

前回の記事では、パフォーマンスの観点で見ると無駄な`await`は省略すべきという内容でしたが、その違いを理解することで、その場の優先度に応じた選択を取れることが大事だと思います。