---
title: "awaitする場合としない場合の比較"
emoji: "⏱️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [javascript, typescript]
published: false
---

前回、不要な`await`について書いた記事の続きです。

@[card](https://zenn.dev/nanase99/articles/856861b792deba)

こちらの記事では、なんとなくで書きがちな`await`について、不要となるケースを記載していました。

```diff js
async function getUsers() {
  const res = await fetch("/api/users");
  if (res.status !== 200) {
    throw new Error("エラーだよ");
  }
  const data = await res.json(); // ← ここでのawaitはあってもなくても動作は変わらない
  return data;
}
```

しかし、比較が不十分だったため、本記事で改めて検証結果を記載します。

## パフォーマンスの比較
今回は下記の3パターンで比較してみました。
- `async await`
- `async no await`
- `no async`

それぞれ下記のように定義しています。

```js
// async関数でawaitする
async function asyncAwait() {
  return await Promise.resolve(0);
}

// async関数でawaitしない
async function asyncNoAwait() {
  return Promise.resolve(0);
}

// 通常の関数
function noAsync() {
  return Promise.resolve(0);
}
```

:::details stackblitzはこちら
`npm run bench`で実行できます。
@[stackblitz](https://stackblitz.com/edit/await-vs-without-await-z6fwvoev-igwc7gys?embed=1&file=async.bench.js&view=editor)
:::

これらをvitestのベンチマークテストで検証した結果がこちらです。

```sh
 ✓ async.bench.js 1981ms
     name                  hz     min     max    mean     p75     p99    p995    p999     rme  samples
   · asyncAwait    297,257.98  0.0000  0.1000  0.0034  0.0050  0.0100  0.0100  0.0150  ±0.44%   148629
   · asyncNoAwait  284,127.16  0.0000  0.1150  0.0035  0.0050  0.0100  0.0100  0.0100  ±0.43%   142065   slowest
   · noAsync       301,016.99  0.0000  1.9750  0.0033  0.0050  0.0100  0.0100  0.0250  ±1.06%   150510   fastest

 BENCH  Summary

  noAsync - async.bench.js
    1.01x faster than asyncAwait
    1.06x faster than asyncNoAwait
```

パッと結果が分かりづらいので、実行速度が速い順に再掲するとこちらのようになります。

```js
// 通常の関数(fastest)
function noAsync() {
  return Promise.resolve(0);
}

// async関数でawaitする
async function asyncAwait() {
  return await Promise.resolve(0);
}

// async関数でawaitしない(slowest)
async function asyncNoAwait() {
  return Promise.resolve(0);
}
```

また、`noAsync`は、
- `asyncAwait`に比べて1.01倍速い
- `asyncNoAwait`に比べて1.06倍速い
結果となっています。

この結果を見ると、`await`を行う`asyncAwait`関数の方が、`await`を行わない`asyncNoAwait`関数よりも速いという結果となっており、直感に反する内容となっています。

ちなみに、下記の記事ではこの順序が逆となっており、`await`を行わない`asyncNoAwait`の方が速い結果となっていますが、これはJavaScriptにおけるPromiseの取り扱いが変わったことによる差異だと思われます。
@[card](https://zenn.dev/catallaxy_dev/articles/7a1610273e79c5)

上述の理由により、ESLintではasync関数で`await`を使用したreturn文を不正とするルールが存在していましたが、現在は非推奨のルールとなっています。
@[card](https://eslint.org/docs/latest/rules/no-return-await)

### awaitを書く場合の方が速いのはなぜ？

`await`を書く場合の方が、書かない場合よりも早くなるのは**hogehoge**からです。


### マイクロタスク

## パフォーマンス以外の視点で見た場合
他にも違いが生じることになります

### スタックトレースが詳細になる

### try/catchの場所

## ESLintとBiomeにおけるルール
ESLintでは、下記のようなルールが存在します。
また、Biomeでも似たようなルールとして下記が存在します。

## まとめ

観点次第

基本的にはスタックトレースが詳細になる`async await`を書くことで

前回の記事では、パフォーマンスの観点で見ると無駄な`await`は省略すべきという考え方でしたが、優先度に応じた選択を取れることが大事だと思います。

## 参考

@[card](https://zenn.dev/azukiazusa/articles/difference-between-return-and-return-await)
@[card](https://zenn.dev/uhyo/articles/return-await-promise)