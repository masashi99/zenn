---
title: "考えなしに書いていたawaitに少しだけ向き合う"
emoji: "⏹️"
type: "tech"
topics: [javascript, typescript]
published: false
---

## はじめに
JavaScript(TypeScript)で非同期処理を書く際に、流れで`await`を書いていないでしょうか？

私はこれまで、`fetch`や`res.json`などを呼び出したらセットで`await`を書いてしまっていましたが、コードレビューで不要な`await`を書いてしまっているとの指摘をいただきました。

そのため、本記事では
- **非同期処理で`await`を書かなくても良いケース**
- **不要な`await`を書いたことによるパフォーマンスの差**
について調査した結果を記載します。

結論としては
- 不必要に`await`を使用するとパフォーマンスが落ちる
- 非同期処理の実行結果を参照しない場合`await`は不要となる

## awaitが不要となる場合

今回指摘をいただいたコードとしては下記のようなものです。

```js
async function getUsers() {
  const res = await fetch("/api/users");
  if (res.status !== 200) {
    throw new Error("エラーだよ");
  }
  const data = await res.json();
  return data;
}
```

内容としては、`fetch`を呼び出し、ステータスコードで成否を判定し、問題なければ`res.json`を呼び出して中身のデータをリターンするといったものです。

上記の書き方をしても動きとしては、特に問題なく動作します。

しかし、このコードでは`await res.json`の`await`は不要な処理となります。

なぜなら、`getUsers`関数内では`res.json`の実行結果を参照せずにリターンしているだけだからです。

つまり、`getUsers`関数の呼び出し元では下記のように`await getUsers`のように書くことになり、`getUsers`内部で`await res.json`と書いても書かなくても、動作に違いはありません。

```js
// getUsersの呼び出し元
async function main() {
  const users = await getUsers(); // ← getUsersがasync functionなのでawaitする必要がある
  // usersを使用する処理
}

// getUsers再掲
async function getUsers() {
  const res = await fetch("/api/users");
  if (res.status !== 200) {
    throw new Error("エラーだよ");
  }
  const data = await res.json();
  return data;
}
```

逆に、必要な`await`は`await fetch`となります。

なぜなら、`getUsers`関数では、ステータスコードによるハンドリングとして`res.status`を参照する必要があり、そのためには`await`を使用して`Promise`を解決する必要があるためです。

また、TypeScriptの世界で考えた場合、`getUsers`の戻り値の型に着目すると、**`await res.json()`と書いても`res.json()`と書いても差はなく`Promise<User[]>`**になります。

```diff ts
type User = {
  id: number;
  name: string;
}

// getUsers再掲（戻り値の型はPromise<User[]>）
async function getUsers(): Promise<User[]> {
  const res = await fetch("/api/users");
  if (res.status !== 200) {
    throw new Error("エラーだよ");
  }
  const data = await res.json();
  return data;
}

// awaitしないバージョン（戻り値の型はPromise<User[]>）
async function withoutAwaitGetUsers(): Promise<User[]> {
  const res = await fetch("/api/users");
  if (res.status !== 200) {
    throw new Error("エラーだよ");
  }
- const data = await res.json();
+ const data = res.json();
  return data;
}
```

このようなシグネチャによる観点からも、内部で`res.json()`に`await`を使用しているかどうかに関わらず、呼び出し元でその実行結果を参照する場合は、`await`を使用することで`Promise<User[]>`から`User[]`を取得する必要があることがわかります。

## 不要なawaitを書くことによる影響

動きとして変わらないのであれば、`await`をつけていても良いのではないか？という解釈もあります。

そこで、実際に`await`をつけることでパフォーマンスにどのような影響が出るかを簡単に調査しました。

@[stackblitz](https://stackblitz.com/edit/await-vs-without-await-z6fwvoev?embed=1&file=readme.md&view=editor)

処理の中身は、Promise.resolveを`await`する/しないの非同期関数を100万回呼び出すような雑なものです。

stackblitz上でそれぞれ5回ずつ実行した結果が下記となります。

| 回数 | awaitする() | awaitしない |
| ---- | ---- | ---- |
| 1回目 | 2.697s | 2.465s |
| 2回目 | 2.697s | 2.478s |
| 3回目 | 2.702s | 2.473s |
| 4回目 | 2.734s | 2.463s |
| 5回目 | 2.772s | 2.492s |

平均して比較すると、**`await`しない方が約0.25秒早い**結果になりました。

今回検証した処理が現実的ではないという話もありますが、コードの違いが関数内部で`await`を書くか書かないかの差だけで、敢えてパフォーマンスを落とすことは避けるべきなので、確かに不要な`await`を避けることには意味がありました。

## 非同期処理であるres.jsonについて

今回の趣旨から少しずれますが、`await`の使い方に関連して、別で注意した方が良いケースがあります。

それは、下記のように`await res.json`の実行結果を参照するような処理の場合、即座に`res.json`を`await`するケースです。

```js
async function getUsersAndProcess() {
  const res = await fetch("/api/user");
  const data = await res.json(); // ← 即座にawaitする
  // dataを参照する処理
}
```

コードからも自明ですが、`fetch`と`res.json`はどちらも非同期関数で、`await`することでフェッチが完了するまで待機することになりますが、両者の処理が完了となるタイミングは異なります。

`await fetch`は**レスポンスヘッダー**の受信が完了するまで待機するのに対して、`await res.json`は**レスポンスボディ**の受信が完了するまで待機することになります。

そのため、ステータスコードが200以外の場合でも、無駄にボディの受信完了まで待ってしまいます。

フェッチする側としては、ステータスコードによるハンドリングを`await res.json`よりも前に書くことで、無駄な待機時間を発生させなくすることが可能ということになります。

```js
const res = await fetch("/api/user");

if (res.status !== 200) {
  return null;
}

const data = await res.json();
```

詳しくは以下の記事が理解しやすいかと思います。
@[card](https://zenn.dev/ryomaejii/articles/a55f428609ffc5)
@[card](https://qiita.com/ssc-ksaitou/items/5989f754fde0a6a0740c)

このように、不要な`await`を避けることで、無駄な待機時間やリソース消費を防ぐことができます。

非同期処理を深く理解していなくても上記のようなコードを書くことが多いとは思いますが、このように書いている理由を知ることも大事かと思います。

## まとめ

- 非同期処理の結果を参照しない場合`await`は不要であり、逆に使用することでパフォーマンスが落ちてしまう。
- ステータスコードによる早期リターンが可能な場合は、`await res.json`の実行前に処理することで、無駄な待機時間の発生を防ぐことが可能。
