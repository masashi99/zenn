---
title: "考えなしに書いていたawaitに少しだけ向き合う"
emoji: "⏹️"
type: "tech"
topics: [javascript]
published: false
---

## はじめに
JavaScriptで非同期処理を書く際に、`await`する位置を気にしたことはあるでしょうか？

私はこれまで、`fetch`や`res.json`などを呼び出す際に処理の完了を待つために`await`が必要という認識で書いていましたが、業務でブロッキングが発生する技術スタックを使用した際に、JavaScriptではこんな安易に同期的な処理を書いて良いのか？と疑問になることがあり今回調べることにしました。

:::message
個人的な解釈の域を出ないので、内容や考え方に誤りがある可能性があります。
:::

### 結論
- JavaScriptで`await`を書いた場合、ブロッキングは発生しないので神経質になる必要はない
- 一方で、理解せずに使ってしまっていると、思わぬところでパフォーマンスが悪くなるため注意が必要
- ブロッキング/ノンブロッキングと同期/非同期は直行する概念

### 対象読者
- 普段JavaScriptばかりを触っていて、async/awaitを雰囲気で書いてしまっている人
- ブロッキングが発生する言語やフレームワークで非同期・並行処理を経験していて、JavaScriptのawaitの位置を気にしている人

## `await`の位置ってそんなに気にする必要あるの？ 〜JavaScriptと他言語のギャップから考える〜

JavaScript ばかり書いていると、非同期処理で`await`をどこに書くかを深く意識せずに使っていることが多いかもしれません。

それは、何となく「`await` すれば非同期処理が終わるまで待てる」くらいの認識で、ほとんどの場合は特に問題なく動いてしまうからです。

しかし、Spring WebFluxやF#などでは、ブロッキングする処理にならないように注意して書く必要があるのに対して、JavaScriptでは気軽に`await`して問題ないのか？と感じることがありした。

というのも、そういった技術スタックでは `await` 相当の処理でスレッドがブロックされることがあり、無自覚に使うと**スレッドプールの枯渇**や**性能劣化**といった問題を引き起こす可能性があるからです。

## JavaScript では「await = ブロック」ではない

JavaScriptの場合はそもそもの事情が異なります。Node.js やブラウザの実行環境では、**イベントループ + 非同期 I/O** というモデルによって、`await` してもスレッドはブロックされません。

// イベントループについて書く

// 非同期I/Oについて書く（ノンブロッキングI/O?）

```ts
const data = await fetchData(); // ← ここで待っている間も他の処理は進む
```

この await は、「この関数内の続きを止める」だけであって、スレッドやイベントループを止めるわけではありません。

そのため、ブロッキング処理を発生させてスレッドを占有してしまうといったことは発生しません。

## とはいえ、どこでも気軽にawaitしていいわけではない
JavaScriptの`await`はブロッキングではありませんが、「考えなしに使っても問題がない」というわけでもありません。

たとえば、APIレスポンスを処理する際に、以下のように即座に`res.json()`を`await`するのは避けた方がいいケースがあります。

```js
const res = await fetch("/api/user");
const data = await res.json(); // ← 無条件で待機
```

`await fetch()`は**レスポンスヘッダー**の受信が完了するまで待機するのに対して、`await res.json()`は**レスポンスボディ**の受信が完了するまで待機することになります。

詳しくはこちらの記事がわかりやすいです。
// リンク書く

そのため、ステータスコードが 204 No Content のような場合でも、無駄にボディの受信完了まで待ってしまいます。

フェッチする側としては、ステータスコードによるハンドリングを`await res.json()`よりも前に書くことで、無駄な待機時間を発生させなくすることが可能ということになります。

```js
const res = await fetch("/api/user");

if (res.status === 204) {
  return null;
}

const data = await res.json();
```

このように、不要な await を避けることで、無駄な待機時間やリソース消費を防ぐことができます。

非同期処理を深く理解していなくても上記のようなコードを書くことが多いとは思いますが、このように書いている理由を知ることも大事かと思います。

## await の位置で設計や挙動が変わる場面もある
また、await の位置は エラーハンドリングの範囲や 並列実行の自由度にも影響します。

例：try/catch のスコープ

```js
try {
  const data = await res.json(); // ここで例外が起きれば捕捉できる
} catch (e) {
  console.error("パース失敗", e);
}
```

逆に`await`を後回しにすると、try/catch の範囲外で例外が発生する可能性があります。

```ts
// 逐次処理（非効率）
const user = await userRepo.findById(userId);
const posts = await postRepo.findByUserId(user.id);

// 並列に実行できる設計
const userPromise = userRepo.findById(userId);
const postsPromise = postRepo.findByUserId(userId);

const user = await userPromise;
const posts = await postsPromise;
```
このように、内部で`await`を使ってしまうと、呼び出し元が並列化しにくくなることもあります。

## まとめ：ちゃんと理解した上で使うならOK
JavaScript では`await`によるブロッキングは発生しない

だからといって`await`の位置を雑に扱っていいわけではない

`res.json()`のような「無駄な待機」や、設計・エラーハンドリング上の影響には注意すべき

結論としては、「パフォーマンス上の問題は少ないが、理解した上で`await`を使うのが大事」

`await`は便利な分、無意識に書いてしまいがちですが、「どこで待つべきか？」「待たずに渡すべきか？」を考えられるようになると、より意図のあるコードが書けるようになります。
